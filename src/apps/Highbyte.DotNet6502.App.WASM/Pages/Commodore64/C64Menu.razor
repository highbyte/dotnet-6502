@using Highbyte.DotNet6502.Impl.AspNet.Commodore64.Input
@using Highbyte.DotNet6502.Systems
@using Highbyte.DotNet6502.Systems.Commodore64.Config;
@using Highbyte.DotNet6502.Systems.Commodore64;
@using Highbyte.DotNet6502.Systems.Commodore64.TimerAndPeripheral.DiskDrive.D64;
@using Highbyte.DotNet6502.Systems.Commodore64.Video;
@using static Highbyte.DotNet6502.App.WASM.Pages.Index;
@using Highbyte.DotNet6502.App.WASM.Emulator.SystemSetup;
@using Highbyte.DotNet6502.Utils;
@using TextCopy
@using System.IO.Compression
@using System.Linq

@if(Parent.Initialized && Parent.WasmHost.SelectedSystemName == SYSTEM_NAME)
{
    <div class="system-command systemCommandsStyle@(SYSTEM_NAME)">

        <button @onclick="CopyBasicSourceCode" disabled=@OnCopySourceCodeDisabled>Copy</button>
        <button @onclick="PasteText" disabled=@OnPasteTextDisabled>Paste</button>
        <p></p>
        <label for="BasicCodingAssistant">AI Basic (F9)</label>
        <input id="BasicCodingAssistant" type="checkbox" @bind="@BasicCodingAssistantEnabled" disabled="@BasicCodingAssistantDisabled"/> <a href="https://github.com/highbyte/dotnet-6502/blob/master/doc/SYSTEMS_C64_AI_CODE_COMPLETION.md" target="_blank">(info)</a>

        <p>&nbsp;</p>
        <details open>
            <summary>Disk Drive & .D64 images</summary>
            <button @onclick="OnDiskFilePicker" disabled=@OnFilePickerDisabled>Attach .d64 disk image</button>
            <a href="https://github.com/highbyte/dotnet-6502/blob/master/doc/SYSTEMS_C64_COMPATIBLE_PRG.md" target="_blank">(info)</a>
            <span>@_latestDiskFileError</span>
            <br />
            <br />
            <label for="preloadedDiskSelector">Download & Run .D64 programs:</label>
            <select id="preloadedDiskSelector" @onchange="OnPreloadedDiskChanged">
                <option value="">-- Select a program --</option>
                @foreach (var disk in _preloadedD64Images)
                {
                    <option value="@disk.Key">@disk.Value.DisplayName</option>
                }
            </select>
            @if (!string.IsNullOrEmpty(SelectedPreloadedDisk))
            {
                <br />
                @if (_isLoadingPreloadedDisk)
                {
                    <span>Loading disk image...</span>
                }
                else
                {
                    <button @onclick="OnLoadPreloadedDisk">Download & Run Game</button>
                }
                <br />
                <span style="font-size: 0.9em; color: #666;">
                    Download D64 disk image and auto-run the program on it.
                </span>
                @if (!string.IsNullOrEmpty(_latestPreloadedDiskError))
                {
                    <br />
                    <span style="color: red;">@_latestPreloadedDiskError</span>
                }
            }
        </details>

        <p>&nbsp;</p>
        <details>
            <summary>Load/Save</summary>
            <p>Load/save files</p>
            <button @onclick="OnBasicFilePicker" disabled=@OnBasicFilePickerDisabled>Load Basic .prg</button>
            <button @onclick="OnSaveBasicFile" disabled=@OnBasicFilePickerDisabled>Save Basic .prg</button>
            <button @onclick="OnFilePicker" disabled=@OnFilePickerDisabled>Load & start binary .prg</button>

            <p>Assembly example files</p>
            <div>
                <select value="@SelectedAssemblyExample" @onchange="OnAssemblyExampleChanged" disabled=@OnFilePickerDisabled>
                    @foreach (var exampleFileKey in _assemblyExampleFiles.Keys)
                    {
                        <option value="@_assemblyExampleFiles[exampleFileKey]"> @exampleFileKey </option>
                    }
                </select>
                <button @onclick="OnLoadAssemblyExample" disabled=@OnFilePickerDisabled>Load & start</button>
            </div>

            <p>Basic example files</p>
            <div>
                <select value="@SelectedBasicExample" @onchange="OnBasicExampleChanged" disabled=@OnFilePickerDisabled>
                    @foreach (var exampleFileKey in _basicExampleFiles.Keys)
                    {
                        <option value="@_basicExampleFiles[exampleFileKey]"> @exampleFileKey </option>
                    }
                </select>
                <button @onclick="OnLoadBasicExample" disabled=@OnFilePickerDisabled>Load</button>
            </div>

            <div class="validation-message">
                <span>@_latestFileError</span>
            </div>
        </details>

        <p>&nbsp;</p>
        <details id="conf_section">
            <summary>Configuration</summary>

            <label for="Joystick">Active joystick</label>
            <select value="@_c64HostConfig.InputConfig.CurrentJoystick" @onchange="OnSelectJoystickChanged">
                @foreach (var joystick in _c64HostConfig.InputConfig.AvailableJoysticks.ToArray())
                {
                    <option value="@joystick"> @joystick </option>
                }
            </select>
        
            <label for="JoystickKeyboardEnabled">Joystick Keyboard</label>
            <input id="JoystickKeyboardEnabled" type="checkbox" @bind="@JoystickKeyboardEnabled" />
            <select value="@KeyboardJoystick" @onchange="OnSelectKeyboardJoystickChanged" disabled=@SelectKeyboardJoystickDisabled>
                @foreach (var joystick in _c64HostConfig.InputConfig.AvailableJoysticks.ToArray())
                {
                    <option value="@joystick"> @joystick </option>
                }
            </select>

            <div class="system-config systemConfigStyle@(SYSTEM_NAME)">
                <button @onclick="ShowConfigUI" class="@(_c64HostConfig.IsValid(out _) ? "": "validation-message")" disabled=@ShowConfigDisabled>C64 Config</button>
            </div>

        </details>
    </div>


    <div class="system-help systemHelpStyle@(SYSTEM_NAME)">
    </div>

    <style>
        .systemCommandsStyle@(SYSTEM_NAME) {
            display: @Parent.Initialized ? @Parent.GetSystemVisibilityDisplayStyle("Commands", SYSTEM_NAME) : "none"
        }

        .systemHelpStyle@(SYSTEM_NAME) {
            display: @Parent.Initialized ? @Parent.GetSystemVisibilityDisplayStyle("Help", SYSTEM_NAME) : "none"
        }

        .systemConfigStyle@(SYSTEM_NAME) {
            display: @Parent.Initialized ? @Parent.GetSystemVisibilityDisplayStyle("Config", SYSTEM_NAME) : "none"
        }
    </style>
}

<InputFile id="filePicker" OnChange="@OnFilePickerChange" @oncancel="OnFilePickerCancel" hidden />
<InputFile id="filePickerBasic" OnChange="@OnBasicFilePickerChange" @oncancel="OnFilePickerCancel" hidden />
<InputFile id="filePickerDisk" OnChange="@OnDiskFilePickerChange" @oncancel="OnFilePickerCancel" hidden />

@* Fix for compiler warning CS8669 https://github.com/dotnet/razor/issues/8720 *@
@{
#pragma warning disable CS8669
} 
@code {
    @inject IJSRuntime Js
    @inject HttpClient HttpClient
    @inject ILoggerFactory LoggerFactory
    @inject IClipboard Clipboard

    [Parameter]
    public Highbyte.DotNet6502.App.WASM.Pages.Index Parent { get; set; } = default!;

    private C64SystemConfig _c64SystemConfig => _c64HostConfig.SystemConfig;
    private C64HostConfig _c64HostConfig => (C64HostConfig)Parent.WasmHost.CurrentHostSystemConfig;
    private C64AspNetInputHandler _c64AspNetInputHandler => (C64AspNetInputHandler)Parent.WasmHost.CurrentSystemRunner!.InputHandler;

    private ILogger _logger = default!;
    private string _latestFileError = "";
    private string _latestDiskFileError = "";
    private string _latestPreloadedDiskError = "";
    private bool _isLoadingPreloadedDisk = false;
    private string SYSTEM_NAME = C64.SystemName;
   
    // CORS proxy URL to bypass browser CORS restrictions when downloading from external sites
    //private const string CORS_PROXY_URL = "https://thingproxy.freeboard.io/fetch/"; // Doesn't seem to work with redirects
    //private const string CORS_PROXY_URL = "https://api.allorigins.win/raw?url="; // Doesn't work reliably
    private const string CORS_PROXY_URL = "https://corsproxy.io/?url=";

    private readonly Dictionary<string, D64ImageInfo> _preloadedD64Images = new()
    {
        {"digiloi", new D64ImageInfo("Digiloi", "https://csdb.dk/release/download.php?id=213381", keyboardJoystickEnabled: true, keyboardJoystickNumber: 2)},
        {"elite", new D64ImageInfo("Elite", "https://csdb.dk/release/download.php?id=254875", keyboardJoystickEnabled: true, keyboardJoystickNumber: 2)},
        {"lastninja", new D64ImageInfo("Last Ninja", "https://csdb.dk/release/download.php?id=101848", downloadType: DownloadType.ZIP, keyboardJoystickEnabled: true, keyboardJoystickNumber: 2)},
        {"minizork", new D64ImageInfo("Mini Zork", "https://csdb.dk/release/download.php?id=42919")},
        {"rally", new D64ImageInfo("Rally Speedway", "https://csdb.dk/release/download.php?id=219614", keyboardJoystickEnabled: true, keyboardJoystickNumber: 1)},
        {"montezuma", new D64ImageInfo("Montezuma's Revenge", "https://csdb.dk/release/download.php?id=128101", downloadType: DownloadType.ZIP, keyboardJoystickEnabled: true, keyboardJoystickNumber: 2)},
        {"bubblebobble", new D64ImageInfo("Bubble Bobble", "https://csdb.dk/release/download.php?id=191127", keyboardJoystickEnabled: true, keyboardJoystickNumber: 2)}
    };
    public string SelectedPreloadedDisk { get; set; } = default!;

    private enum DownloadType
    {
        /// <summary>
        /// A .d64 file.
        /// </summary>
        D64,
        
        /// <summary>
        /// A .zip file that contains a .d64 file.
        /// </summary>
        ZIP
    }

    private class D64ImageInfo
    {
        public string DisplayName { get; set; }
        public string DownloadUrl { get; set; }
        public List<string> RunCommands { get; set; }
        public DownloadType DownloadType { get; set; }
        public bool KeyboardJoystickEnabled { get; set; }
        public int KeyboardJoystickNumber { get; set; }

        public D64ImageInfo(string displayName, string downloadUrl, List<string>? runCommands = null, DownloadType downloadType = DownloadType.D64, bool keyboardJoystickEnabled = false, int keyboardJoystickNumber = 2)
        {
            DisplayName = displayName;
            DownloadUrl = downloadUrl;
            RunCommands = runCommands ?? new List<string> { "load\"*\",8,1", "run" };
            DownloadType = downloadType;
            KeyboardJoystickEnabled = keyboardJoystickEnabled;
            KeyboardJoystickNumber = keyboardJoystickNumber;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // If config isn't valid, expand HTML details element for conf (setting property open to true)
        if (firstRender)
        {
            if (!_c64HostConfig.IsValid(out _))
            {
                await Js.InvokeVoidAsync("setOpen", "conf_section", true);
            }
        }
    }

    protected override void OnInitialized()
    {
        _logger = LoggerFactory.CreateLogger<C64Menu>();
        _logger.LogDebug("OnInitializedAsync() was called");

    }

    private void OnSelectJoystickChanged(ChangeEventArgs e)
    {
        var joystick = int.Parse(e.Value!.ToString()!);
        _c64HostConfig.InputConfig.CurrentJoystick = joystick;
        Parent.WasmHost.UpdateHostSystemConfig(_c64HostConfig);
    }

    private bool JoystickKeyboardEnabled
    {
        get
        {
            return _c64SystemConfig?.KeyboardJoystickEnabled ?? false;
        }
        set
        {
            _c64SystemConfig.KeyboardJoystickEnabled = value;
            Parent.WasmHost.UpdateHostSystemConfig(_c64HostConfig);

            // If system is running, also make sure to update the joystick setting in the running system
            if (Parent.CurrentEmulatorState != EmulatorState.Uninitialized)
            {
                C64 c64 = (C64)Parent.WasmHost.CurrentRunningSystem!;
                c64.Cia.Joystick.KeyboardJoystickEnabled = value;
            }
        }
    }

    private Task OnSelectKeyboardJoystickChanged(ChangeEventArgs e)
    {
        KeyboardJoystick = int.Parse(e.Value!.ToString()!);
        return Task.CompletedTask;
    }

    private int KeyboardJoystick
    {
        get
        {
            return _c64SystemConfig?.KeyboardJoystick ?? 0;
        }
        set
        {
            _c64SystemConfig.KeyboardJoystick = value;
            Parent.WasmHost.UpdateHostSystemConfig(_c64HostConfig);

            // If system is running, also make sure to update the joystick setting in the running system
            if (Parent.CurrentEmulatorState != EmulatorState.Uninitialized)
            {
                C64 c64 = (C64)Parent.WasmHost.CurrentRunningSystem!;
                c64.Cia.Joystick.KeyboardJoystick = value;
            }
        }
    }

    private bool SelectKeyboardJoystickDisabled => !JoystickKeyboardEnabled;

    private bool BasicCodingAssistantEnabled
    {
        get
        {
            if (Parent.WasmHost.EmulatorState != EmulatorState.Running)
                return false;
            return _c64AspNetInputHandler.CodingAssistantEnabled;
        }
        set
        {
            if (Parent.WasmHost.EmulatorState != EmulatorState.Running)
                return;
            _c64AspNetInputHandler.CodingAssistantEnabled = value;
            ((C64HostConfig)Parent.WasmHost.CurrentHostSystemConfig).BasicAIAssistantDefaultEnabled = value;
        }
    }

    private readonly Dictionary<string, string> _assemblyExampleFiles = new()
    {
        {"","" },
        {"SmoothScroller", "6502binaries/C64/Assembler/smooth_scroller_and_raster.prg" },
        {"Scroller", "6502binaries/C64/Assembler/scroller_and_raster.prg" }
    };
    private readonly Dictionary<string, string> _basicExampleFiles = new()
    {
        {"","" },
        {"HelloWorld", "6502binaries/C64/Basic/HelloWorld.prg" },
        {"PlaySound", "6502binaries/C64/Basic/PlaySoundVoice1TriangleScale.prg" }
    };

    public string SelectedAssemblyExample { get; set; } = default!;

    public string SelectedBasicExample { get; set; } = default!;

    private bool _wasRunningBeforeFileDialog = false;

    private async Task ShowConfigUI() => await Parent.ShowConfigUI<C64ConfigUI>();


    protected bool ShowConfigDisabled => Parent.CurrentEmulatorState != EmulatorState.Uninitialized;

    protected bool OnFilePickerDisabled => Parent.CurrentEmulatorState == EmulatorState.Uninitialized;

    protected bool OnBasicFilePickerDisabled => Parent.CurrentEmulatorState == EmulatorState.Uninitialized;

    protected bool OnCopySourceCodeDisabled=> Parent.CurrentEmulatorState == EmulatorState.Uninitialized;
    
    protected bool OnPasteTextDisabled => Parent.CurrentEmulatorState == EmulatorState.Uninitialized;
    protected bool BasicCodingAssistantDisabled => Parent.CurrentEmulatorState != EmulatorState.Running || 
        Parent.WasmHost.CurrentSystemRunner?.InputHandler is not C64AspNetInputHandler inputHandler || 
        !inputHandler.CodingAssistantAvailable;


    /// <summary>
    /// Open Load binary file dialog
    /// </summary>
    /// <returns></returns>
    private async Task OnFilePicker(MouseEventArgs mouseEventArgs)
    {
        _wasRunningBeforeFileDialog = Parent.CurrentEmulatorState == EmulatorState.Running;
        await Parent.OnPause(new());
        await Js.InvokeVoidAsync("clickId", "filePicker");
    }

    /// <summary>
    /// Callback when binary file has been loaded from file pick dialog
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    private async Task OnFilePickerChange(InputFileChangeEventArgs e)
    {
        if (Parent.CurrentEmulatorState == EmulatorState.Uninitialized)
            return;

        try
        {
            // Only expect one file
            if (e.FileCount > 1)
                return;
            var file = e.File;
            _logger.LogInformation($"File picked: {file.Name} Size: {file.Size}");

            _latestFileError = "";
            var fileBuffer = new byte[file.Size];
            //var fileStream = e.File.OpenReadStream(file.Size);
            await file.OpenReadStream().ReadAsync(fileBuffer);
            var fileSize = fileBuffer.Length;

            // Load file into memory, assume starting at address specified in two first bytes of .prg file
            BinaryLoader.Load(
                Parent.WasmHost.CurrentRunningSystem!.Mem,
                fileBuffer,
                out ushort loadedAtAddress,
                out ushort fileLength);

            _logger.LogInformation($"File loaded at {loadedAtAddress.ToHex()}, length {fileLength.ToHex()}");

            _logger.LogInformation($"Starting loaded program by changing Program Counter to {loadedAtAddress.ToHex()}");
            Parent.WasmHost.CurrentRunningSystem!.CPU.PC = loadedAtAddress;

        }
        catch (Exception ex)
        {
            _latestFileError = $"Load error: {ex.Message}";
            _logger.LogError($"Load error: {ex.Message}");
        }
        finally
        {
            if (_wasRunningBeforeFileDialog)
                await Parent.OnStart(new());
        }
    }

    /// <summary>
    /// Open Load Basic .prg file dialog
    /// </summary>
    /// <returns></returns>
    private async Task OnBasicFilePicker(MouseEventArgs mouseEventArgs)
    {
        _wasRunningBeforeFileDialog = Parent.CurrentEmulatorState == EmulatorState.Running;
        await Parent.OnPause(new());
        await Js.InvokeVoidAsync("clickId", "filePickerBasic");
    }

    private async Task OnFilePickerCancel(EventArgs e)
    {
        if (_wasRunningBeforeFileDialog)
            await Parent.OnStart(new());
    }


    /// <summary>
    /// Callback when C64 basic file (.prg) has been loaded from file pick dialog (from main UI, not monitor)
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    private async Task OnBasicFilePickerChange(InputFileChangeEventArgs e)
    {
        if (Parent.CurrentEmulatorState == EmulatorState.Uninitialized)
            return;

        try
        {
            // Only expect one file
            if (e.FileCount > 1)
                return;
            var file = e.File;
            _logger.LogInformation($"File picked: {file.Name} Size: {file.Size}");

            _latestFileError = "";
            var fileBuffer = new byte[file.Size];
            //var fileStream = e.File.OpenReadStream(file.Size);
            await file.OpenReadStream().ReadAsync(fileBuffer);
            var fileSize = fileBuffer.Length;

            // Load file into memory, assume starting at address specified in two first bytes of .prg file
            BinaryLoader.Load(
                Parent.WasmHost.CurrentRunningSystem!.Mem,
                fileBuffer,
                out ushort loadedAtAddress,
                out ushort fileLength);

            if (loadedAtAddress != C64.BASIC_LOAD_ADDRESS)
            {
                // Probably not a Basic program that was loaded. Don't init BASIC memory variables.
                _logger.LogWarning($"Warning: Loaded program is not a Basic program, it's expected to load at {C64.BASIC_LOAD_ADDRESS.ToHex()} but was loaded at {loadedAtAddress.ToHex()}");
            }
            else
            {
                // Init C64 BASIC memory variables
                ((C64)Parent.WasmHost.CurrentRunningSystem!).InitBasicMemoryVariables(loadedAtAddress, fileLength);
            }

            _logger.LogInformation($"Basic program loaded at {loadedAtAddress.ToHex()}, length {fileLength.ToHex()}");
        }
        catch (Exception ex)
        {
            _latestFileError = $"Load error: {ex.Message}";
            _logger.LogError($"Load error: {ex.Message}");
        }
        finally
        {
            if (_wasRunningBeforeFileDialog)
                await Parent.OnStart(new());
        }
    }

    private async Task OnSaveBasicFile(MouseEventArgs mouseEventArgs)
    {
        if (Parent.CurrentEmulatorState == EmulatorState.Uninitialized)
            return;

        var result = await Parent.Modal.Show<EnterFileName>().Result;
        if (result.Confirmed)
        {
            if (result.Data is null)
                return;
            var fileName = (string)result.Data;
            if (string.IsNullOrEmpty(fileName))
                return;
            string ext = Path.GetExtension(fileName);
            if (string.IsNullOrEmpty(ext))
                fileName += ".prg";

            try
            {
                _latestFileError = "";
                var startAddress = C64.BASIC_LOAD_ADDRESS;
                var endAddress = ((C64)Parent.WasmHost.CurrentRunningSystem!).GetBasicProgramEndAddress();
                var saveData = BinarySaver.BuildSaveData(Parent.WasmHost.CurrentRunningSystem!.Mem, startAddress, endAddress, addFileHeaderWithLoadAddress: true);
                var fileStream = new MemoryStream(saveData);
                using var streamRef = new DotNetStreamReference(stream: fileStream);
                // Invoke JS helper script to trigger save dialog to users browser downloads folder
                await Js.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
            }
            catch (Exception ex)
            {
                _latestFileError = $"Save error: {ex.Message}";
                _logger.LogError($"Save error: {ex.Message}");   
            }
        }
    }


    private void OnAssemblyExampleChanged(ChangeEventArgs e)
    {
        SelectedAssemblyExample = e.Value?.ToString() ?? "";
    }

    private async Task OnLoadAssemblyExample(MouseEventArgs mouseEventArgs)
    {
        var url = SelectedAssemblyExample;
        if (string.IsNullOrEmpty(url))
            return;

        await Parent.OnPause(new());

        try
        {
            _latestFileError = "";
            var prgBytes = await HttpClient!.GetByteArrayAsync(url);
            // Load file into memory, assume starting at address specified in two first bytes of .prg file
            BinaryLoader.Load(
                Parent.WasmHost.CurrentRunningSystem!.Mem,
                prgBytes,
                out ushort loadedAtAddress,
                out ushort fileLength);

            _logger.LogInformation($"File loaded at {loadedAtAddress.ToHex()}, length {fileLength.ToHex()}");

            _logger.LogInformation($"Starting loaded program by changing Program Counter to {loadedAtAddress.ToHex()}");
            Parent.WasmHost.CurrentRunningSystem!.CPU.PC = loadedAtAddress;
        }
        catch (Exception ex)
        {
            _latestFileError = $"Load error: {ex.Message}";
            _logger.LogError($"Load error: {ex.Message}");
        }

        await Parent.OnStart(new());
    }

    private void OnBasicExampleChanged(ChangeEventArgs e)
    {
        SelectedBasicExample = e.Value?.ToString() ?? "";
    }

    private async Task OnLoadBasicExample(MouseEventArgs mouseEventArgs)
    {
        string url = SelectedBasicExample;
        if (string.IsNullOrEmpty(url))
            return;

        await Parent.OnPause(new());

        try
        {
            _latestFileError = "";
            var prgBytes = await HttpClient!.GetByteArrayAsync(url);

            // Load file into memory, assume starting at address specified in two first bytes of .prg file
            BinaryLoader.Load(
                Parent.WasmHost.CurrentRunningSystem!.Mem,
                prgBytes,
                out ushort loadedAtAddress,
                out ushort fileLength);

            var c64 = (C64)Parent.WasmHost.CurrentRunningSystem!;
            if (loadedAtAddress != C64.BASIC_LOAD_ADDRESS)
            {
                // Probably not a Basic program that was loaded. Don't init BASIC memory variables.
                System.Diagnostics.Debug.WriteLine($"Warning: Loaded program is not a Basic program, it's expected to load at {C64.BASIC_LOAD_ADDRESS.ToHex()} but was loaded at {loadedAtAddress.ToHex()}");
            }
            else
            {
                // Init C64 BASIC memory variables
                c64.InitBasicMemoryVariables(loadedAtAddress, fileLength);
            }

            // Send "list" + NewLine (Return) to the keyboard buffer to immediately list the loaded program.
            // Bypass keyboard matrix scanning and send directly to keyboard buffer.
            c64.TextPaste.Paste("list\n");

        }
        catch (Exception ex)
        {
            _latestFileError = $"Load error: {ex.Message}";
            _logger.LogError($"Load error: {ex.Message}");
        }

        await Parent.OnStart(new());
    }

    private async Task CopyBasicSourceCode()
    {
        var c64 = (C64)Parent.WasmHost.CurrentRunningSystem!;
        var sourceCode = c64.BasicTokenParser.GetBasicText();
        await Clipboard.SetTextAsync(sourceCode.ToLower());
        await Parent.FocusEmulator();
    }

    private async Task PasteText()
    {
        var c64 = (C64)Parent.WasmHost.CurrentRunningSystem!;
        var text = await Clipboard.GetTextAsync();
        if (string.IsNullOrEmpty(text))
            return;
        c64.TextPaste.Paste(text);

        await Parent.FocusEmulator();
    }

    /// <summary>
    /// Open Attach .d64 disk image file dialog
    /// </summary>
    /// <returns></returns>
    private async Task OnDiskFilePicker(MouseEventArgs mouseEventArgs)
    {
        _wasRunningBeforeFileDialog = Parent.CurrentEmulatorState == EmulatorState.Running;
        await Parent.OnPause(new());
        await Js.InvokeVoidAsync("clickId", "filePickerDisk");
    }

    /// <summary>
    /// Callback when .d64 disk image file has been loaded from file pick dialog
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    private async Task OnDiskFilePickerChange(InputFileChangeEventArgs e)
    {
        if (Parent.CurrentEmulatorState == EmulatorState.Uninitialized)
            return;
        try
        {
            if (e.FileCount > 1)
                return;
            var file = e.File;
            _logger.LogInformation($"Disk file picked: {file.Name} Size: {file.Size}");
            _latestDiskFileError = "";
            var fileBuffer = new byte[file.Size];
            await file.OpenReadStream().ReadAsync(fileBuffer);
            // Parse the D64 disk image from the byte array
            var d64DiskImage = D64Parser.ParseD64File(fileBuffer);
            // Set the disk image on the running C64's DiskDrive1541
            var c64 = (C64)Parent.WasmHost.CurrentRunningSystem!;
            var diskDrive = c64.IECBus?.Devices?.OfType<Highbyte.DotNet6502.Systems.Commodore64.TimerAndPeripheral.DiskDrive.DiskDrive1541>().FirstOrDefault();
            if (diskDrive != null)
            {
                diskDrive.SetD64DiskImage(d64DiskImage);
                _logger.LogInformation($"Disk image loaded and set: {d64DiskImage.DiskName}");
            }
            else
            {
                _latestDiskFileError = "No DiskDrive1541 found in the running C64 system.";
                _logger.LogError(_latestDiskFileError);
            }
        }
        catch (Exception ex)
        {
            _latestDiskFileError = $"Disk load error: {ex.Message}";
            _logger.LogError(_latestDiskFileError);
        }
        finally
        {
            if (_wasRunningBeforeFileDialog)
                await Parent.OnStart(new());
        }
    }

    /// <summary>
    /// Extracts the first .d64 file from a ZIP archive
    /// </summary>
    /// <param name="zipBytes">The ZIP file as byte array</param>
    /// <returns>The .d64 file content as byte array</returns>
    /// <exception cref="InvalidOperationException">Thrown when no .d64 file is found in the ZIP</exception>
    private static byte[] ExtractFirstD64FromZip(byte[] zipBytes)
    {
        using var zipStream = new MemoryStream(zipBytes);
        using var archive = new ZipArchive(zipStream, ZipArchiveMode.Read);
        
        // Find the first .d64 file in the archive
        var d64Entry = archive.Entries.FirstOrDefault(entry => 
            entry.Name.EndsWith(".d64", StringComparison.OrdinalIgnoreCase));
        
        if (d64Entry == null)
        {
            throw new InvalidOperationException("No .d64 file found in the ZIP archive");
        }
        
        // Pre-allocate array with the exact size to avoid memory fragmentation
        var d64Bytes = new byte[d64Entry.Length];
        
        // Extract the .d64 file content directly into the pre-allocated array
        using var entryStream = d64Entry.Open();
        int totalBytesRead = 0;
        int bytesRead;
        
        // Read in chunks to be memory-efficient
        while (totalBytesRead < d64Bytes.Length && 
               (bytesRead = entryStream.Read(d64Bytes, totalBytesRead, d64Bytes.Length - totalBytesRead)) > 0)
        {
            totalBytesRead += bytesRead;
        }
        
        return d64Bytes;
    }

    /// <summary>
    /// Downloads and processes a disk image file (supports both .d64 and .zip files)
    /// </summary>
    /// <param name="diskInfo">Information about the disk to download</param>
    /// <returns>The .d64 file content as byte array</returns>
    private async Task<byte[]> DownloadAndProcessDiskImage(D64ImageInfo diskInfo)
    {
        _logger.LogInformation($"Downloading disk image: {diskInfo.DisplayName} from {diskInfo.DownloadUrl}");

        // Use CORS proxy to bypass browser CORS restrictions
        var proxiedUrl = CORS_PROXY_URL + Uri.EscapeDataString(diskInfo.DownloadUrl);
        _logger.LogInformation($"Using proxied URL: {proxiedUrl}");

        // Check the download type to determine download strategy
        if (diskInfo.DownloadType == DownloadType.ZIP)
        {
            _logger.LogInformation("Processing ZIP file to extract .d64");
            return await DownloadAndExtractZipD64(proxiedUrl);
        }
        else
        {
            // Download direct .d64 file
            using var response = await HttpClient!.GetAsync(proxiedUrl);
            response.EnsureSuccessStatusCode();
            var d64Bytes = await response.Content.ReadAsByteArrayAsync();
            _logger.LogInformation($"Downloaded .d64 file: {d64Bytes.Length} bytes");
            return d64Bytes;
        }
    }

    /// <summary>
    /// Downloads a ZIP file and extracts the first .d64 file in a memory-efficient way
    /// </summary>
    /// <param name="url">The URL to download the ZIP from</param>
    /// <returns>The .d64 file content as byte array</returns>
    private async Task<byte[]> DownloadAndExtractZipD64(string url)
    {
        using var response = await HttpClient!.GetAsync(url);
        response.EnsureSuccessStatusCode();
        
        // Use the response stream directly instead of loading everything into memory
        using var responseStream = await response.Content.ReadAsStreamAsync();
        using var archive = new ZipArchive(responseStream, ZipArchiveMode.Read);
        
        // Find the first .d64 file in the archive
        var d64Entry = archive.Entries.FirstOrDefault(entry => 
            entry.Name.EndsWith(".d64", StringComparison.OrdinalIgnoreCase));
        
        if (d64Entry == null)
        {
            throw new InvalidOperationException("No .d64 file found in the ZIP archive");
        }
        
        _logger.LogInformation($"Found .d64 file in ZIP: {d64Entry.Name}, size: {d64Entry.Length} bytes");
        
        // Pre-allocate array with the exact size
        var d64Bytes = new byte[d64Entry.Length];
        
        // Extract the .d64 file content directly
        using var entryStream = d64Entry.Open();
        int totalBytesRead = 0;
        int bytesRead;
        
        // Read in chunks to be memory-efficient
        while (totalBytesRead < d64Bytes.Length && 
               (bytesRead = await entryStream.ReadAsync(d64Bytes, totalBytesRead, d64Bytes.Length - totalBytesRead)) > 0)
        {
            totalBytesRead += bytesRead;
        }
        
        _logger.LogInformation($"Extracted .d64 file: {d64Bytes.Length} bytes");
        return d64Bytes;
    }

    private void OnPreloadedDiskChanged(ChangeEventArgs e)
    {
        SelectedPreloadedDisk = e.Value?.ToString() ?? "";
        _latestPreloadedDiskError = "";
    }

    /// <summary>
    /// Download and load a preloaded D64 disk image, then auto-load and run the specified program
    /// </summary>
    /// <returns></returns>
    private async Task OnLoadPreloadedDisk()
    {
        if (string.IsNullOrEmpty(SelectedPreloadedDisk) || !_preloadedD64Images.ContainsKey(SelectedPreloadedDisk))
            return;

        var diskInfo = _preloadedD64Images[SelectedPreloadedDisk];

        try
        {
            _isLoadingPreloadedDisk = true;
            _latestPreloadedDiskError = "";
            StateHasChanged(); // Update UI to show loading state
            
            // First reset the C64 emulator
            _logger.LogInformation("Resetting C64 emulator before loading disk image");

            if (Parent.CurrentEmulatorState == EmulatorState.Running || Parent.CurrentEmulatorState == EmulatorState.Paused)
            {
                _logger.LogInformation("Stopping C64 emulator to reset state");
                await Parent.OnStop(new());
            }

            // Apply keyboard joystick settings to config object while emulator is stopped
            _logger.LogInformation($"Setting keyboard joystick enabled in config to: {diskInfo.KeyboardJoystickEnabled}");
            _c64SystemConfig.KeyboardJoystickEnabled = diskInfo.KeyboardJoystickEnabled;
            _logger.LogInformation($"Setting keyboard joystick number in config to: {diskInfo.KeyboardJoystickNumber}");
            _c64SystemConfig.KeyboardJoystick = diskInfo.KeyboardJoystickNumber;

            Parent.WasmHost.UpdateHostSystemConfig(_c64HostConfig);
            StateHasChanged(); // Update UI to show any config changes

            // Start the C64 emulator
            _logger.LogInformation("Starting C64 emulator");
            await Parent.OnStart(new());

            // Wait for BASIC to start (check periodically)
            _logger.LogInformation("Waiting for BASIC to start...");
            var maxWaitTime = TimeSpan.FromSeconds(20);
            var startTime = DateTime.Now;
            var checkInterval = TimeSpan.FromMilliseconds(100);
            
            C64 c64 = (C64)Parent.WasmHost.CurrentRunningSystem!;
            while (!c64.HasBasicStarted())
            {
                if (DateTime.Now - startTime > maxWaitTime)
                {
                    throw new TimeoutException("Timeout waiting for BASIC to start");
                }
                await Task.Delay(checkInterval);
            }
            
            _logger.LogInformation("BASIC has started successfully");
            
            // Add a 1-second delay to allow BASIC to settle before proceeding
            _logger.LogInformation("Waiting 1 second for BASIC to settle...");
            await Task.Delay(1000);
            
            // Pause before proceeding with disk operations
            await Parent.OnPause(new());
            
            // Download and process the disk image (supports both .d64 and .zip files)
            var d64Bytes = await DownloadAndProcessDiskImage(diskInfo);

            // Parse the D64 disk image
            var d64DiskImage = D64Parser.ParseD64File(d64Bytes);
            _logger.LogInformation($"Parsed D64 disk image: {d64DiskImage.DiskName}");

            // Set the disk image on the running C64's DiskDrive1541
            var diskDrive = c64.IECBus?.Devices?.OfType<Highbyte.DotNet6502.Systems.Commodore64.TimerAndPeripheral.DiskDrive.DiskDrive1541>().FirstOrDefault();
            if (diskDrive != null)
            {
                diskDrive.SetD64DiskImage(d64DiskImage);
                _logger.LogInformation($"Disk image loaded and set: {d64DiskImage.DiskName}");

                // Refresh UI to reflect the new settings values
                this.StateHasChanged();

                // Auto-load and run the program
                if (diskInfo.RunCommands != null && diskInfo.RunCommands.Count > 0)
                {
                    _logger.LogInformation($"Auto-loading and running program with {diskInfo.RunCommands.Count} commands");
                    
                    // Execute each command in sequence
                    foreach (var command in diskInfo.RunCommands)
                    {
                        _logger.LogInformation($"Executing command: {command}");
                        c64.TextPaste.Paste($"{command}\n");
                        
                        // Wait a moment between commands (except for the last one)
                        if (command != diskInfo.RunCommands.Last())
                        {
                            await Task.Delay(1000);
                        }
                    }
                }
            }
            else
            {
                _latestPreloadedDiskError = "No DiskDrive1541 found in the running C64 system.";
                _logger.LogError(_latestPreloadedDiskError);
            }
        }
        catch (Exception ex)
        {
            _latestPreloadedDiskError = $"Load error: {ex.Message}";
            _logger.LogError(_latestPreloadedDiskError);
        }
        finally
        {
            _isLoadingPreloadedDisk = false;
            StateHasChanged(); // Update UI to hide loading state
            
            await Parent.OnStart(new());
        }
    }
}